<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3Då¤©æ°—å›³ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ï¼ˆå­¦æ ¡ç‰ˆï¼‰</title>

<!-- Google Fontsï¼ˆä¸¸ã‚´ï¼‰ -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;600;800&display=swap" rel="stylesheet">

<!-- three.js & addons via importmap -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
  }
}
</script>

<style>
  :root{
    /* å­¦æ ¡ç‰ˆã®ã‚„ã‚ã‚‰ã‹é…è‰² */
    --bg1:#f0f7ff;        /* èƒŒæ™¯ã‚°ãƒ©ãƒ‡1 */
    --bg2:#e8fff6;        /* èƒŒæ™¯ã‚°ãƒ©ãƒ‡2 */
    --panel:#ffffff;      /* ãƒ‘ãƒãƒ«èƒŒæ™¯ */
    --muted:#64748b;      /* èª¬æ˜æ–‡å­— */
    --border:#dbe3ee;     /* ç½«ç·š */
    --accent:#4f46e5;     /* ã‚¢ã‚¯ã‚»ãƒ³ãƒˆï¼ˆã‚¤ãƒ³ãƒ‡ã‚£ã‚´ï¼‰ */
    --accent-2:#06b6d4;   /* ã‚µãƒ–ï¼ˆã‚·ã‚¢ãƒ³ï¼‰ */
    --chip:#eef2ff;       /* ãƒãƒƒãƒ—èƒŒæ™¯ */
  }

  /* èƒŒæ™¯ã¯ã‚„ã•ã—ã„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‹ä¸¸ã‚´ */
  html,body{
    height:100%; margin:0;
    background: linear-gradient(145deg, var(--bg1), var(--bg2));
    color:#0f172a;
    font-family:'M PLUS Rounded 1c',"Hiragino Maru Gothic ProN","Yu Gothic",Meiryo,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    letter-spacing:.01em;
  }

  #app{display:grid;grid-template-columns:1fr 420px;grid-template-rows:72px 1fr;height:100%}
  #app[data-panel="closed"]{grid-template-columns:1fr 0}

  /* ãƒ˜ãƒƒãƒ€ãƒ¼ï¼šã‚«ãƒ©ãƒ•ãƒ«ã§å…ƒæ°—ã« */
  header{
    grid-column:1/-1;display:flex;align-items:center;gap:.7rem;
    padding:.8rem 1rem;border-bottom:1px solid var(--border);
    background: linear-gradient(90deg,#ffffffdd,#ffffffdd);
    backdrop-filter: blur(6px);
    position:relative
  }
  header h1{font-size:18px;margin:0;font-weight:800;display:flex;align-items:center;gap:.5rem}
  header h1::before{content:"ğŸŒ¤ï¸"; font-size:20px}
  header .sp{flex:1}
  header a{font-size:13px;color:var(--accent);text-decoration:none}
  header a:hover{text-decoration:underline}
  header button,header label,header select{
    background:#fff;border:1px solid var(--border);color:#0f172a;
    padding:.55rem .8rem;border-radius:.75rem;cursor:pointer;font-size:14px;
    box-shadow:0 2px 0 #0000000a; transition:transform .05s ease, box-shadow .2s ease, border-color .2s ease;
  }
  header button:hover, header select:hover{border-color:#c6d0e1}
  header button:active{transform:translateY(1px)}
  header button.emoji::before{margin-right:.35rem}
  header input[type=file]{display:none}

  /* ãƒ“ãƒ¥ãƒ¼ã‚¢ */
  #viewer{position:relative;background:#fff;border-top:1px solid var(--border)}
  #c{width:100%;height:100%}
  #overlay{
    position:absolute;left:12px;bottom:12px;
    padding:.55rem .7rem;background:#ffffffcc;border:1px solid var(--border);
    border-radius:.8rem;font-size:13px;color:#334155;box-shadow:0 4px 20px #00000010;
  }
  #overlay::before{content:"ğŸ–±ï¸ ";}

  /* ãƒ‰ãƒ©ãƒƒã‚°HUD */
  #dragHud{
    position:absolute;pointer-events:none;transform:translate(-50%,-130%);
    padding:.3rem .5rem;font-size:13px;border-radius:.5rem;background:#0009;color:#fff;border:1px solid #0003;display:none;white-space:nowrap
  }

  /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
  #sidebar{
    background:var(--panel);border-left:1px solid var(--border);overflow:auto;padding:1rem .9rem
  }
  #app[data-panel="closed"] #sidebar{display:none}
  .section{margin-bottom:1rem}
  .section h2{font-size:14px;margin:.4rem 0 .2rem;font-weight:800;display:flex;align-items:center;gap:.4rem}
  .section h2 .emo{opacity:.9}

  .row{display:grid;grid-template-columns:1fr auto;gap:.7rem;align-items:center;margin:.5rem 0}
  .row label{font-size:13px;color:var(--muted)}
  #list{display:grid;gap:.7rem}

  /* ã‚«ãƒ¼ãƒ‰ï¼ˆã‚„ã•ã—ã„è§’ã¨è‰²ï¼‰ */
  .card{
    border:1px solid var(--border);background:#fff;border-radius:1rem;padding:.7rem .7rem .6rem;
    box-shadow:0 4px 14px #0000000a
  }
  .card .t{display:flex;gap:.6rem;align-items:center;margin-bottom:.35rem}
  .chip{
    display:inline-flex;align-items:center;gap:.4rem;border:1px solid var(--border);
    background:var(--chip); padding:.25rem .55rem;border-radius:999px;font-size:12px;font-weight:700;color:#334155
  }
  .small{font-size:12px}
  .muted{color:#6b7280;font-size:12px;margin-left:.4rem}
  canvas.grabbing{cursor:grabbing}
  canvas.hovering{cursor:ns-resize}

  /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼ˆé–‹ã/æ›¸ãå‡ºã—ï¼‰ */
  .menu{position:absolute; z-index:5; background:#fff; border:1px solid var(--border); border-radius:.9rem; box-shadow:0 12px 32px #0002; padding:.35rem; display:none; min-width:200px}
  .menu.open{display:block}
  .menu button{display:block; width:100%; text-align:left; padding:.65rem .9rem; border:none; background:transparent; border-radius:.7rem; font-size:14px}
  .menu button:hover{background:#f1f5f9}
  .menu .sep{height:1px; background:#e5e7eb; margin:.25rem .25rem}
  .card.focus-ring{outline:2px solid var(--accent); box-shadow:0 0 0 4px #4f46e530}

  /* ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å°‘ã—å¤ªããƒ»å¤§ãã‚ã« */
  input[type=range]{width:220px}
  input[type=range]::-webkit-slider-thumb{
    appearance:none; width:18px;height:18px;border-radius:12px;background:var(--accent);
    border:2px solid #fff; box-shadow:0 1px 3px #00000022; margin-top:-7px
  }
  input[type=range]::-webkit-slider-runnable-track{height:6px;border-radius:999px;background:linear-gradient(90deg,var(--accent),var(--accent-2))}
  input[type=color]{width:36px;height:28px;border-radius:8px;border:1px solid var(--border);padding:0}

  /* ã‚»ãƒ¬ã‚¯ãƒˆã¨ãƒœã‚¿ãƒ³ã«çµµæ–‡å­— */
  #openBtn::before{content:"ğŸ“‚ ";} #exportBtn::before{content:"ğŸ’¾ ";} #panelToggle::before{content:"ğŸ§° ";}
</style>
</head>
<body>
<div id="app" data-panel="open">
  <header>
    <h1>3Då¤©æ°—å›³ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ï¼ˆå­¦æ ¡ç‰ˆï¼‰</h1>

    <a href="https://www.data.jma.go.jp/yoho/wxchart/quickmonthly.html" target="_blank" rel="noopener noreferrer">
      æ°—è±¡åºã®å¤©æ°—å›³ï¼ˆå‚è€ƒï¼‰
    </a>

    <span class="sp"></span>

    <select id="projection" title="ã‚«ãƒ¡ãƒ©ã®æŠ•å½±æ³•">
      <option value="persp" selected>é€è¦–å›³æ³•</option>
      <option value="ortho">æ­£å°„å½±å›³æ³•</option>
    </select>
    <select id="viewSelect" title="è¦‹ã‚„ã™ã„å‘ãã«åˆ‡ã‚Šæ›¿ãˆ">
      <option value="all">æ–œã‚è¦–ç‚¹</option>
      <option value="top">çœŸä¸Šï¼ˆXYï¼‰</option>
      <option value="front">æ­£é¢ï¼ˆZXï¼‰</option>
      <option value="side">å´é¢ï¼ˆZYï¼‰</option>
    </select>

    <!-- é–‹ãï¼ˆçµ±åˆï¼‰ -->
    <button id="openBtn">é–‹ã â–¾</button>
    <input id="fileRaw" type="file" accept=".svg,.svgz,image/svg+xml,application/gzip">
    <input id="fileSaved" type="file" accept=".svg">
    <div id="openMenu" class="menu">
      <button data-act="open-raw">SVG/SVGZã‚’é–‹ãï¼ˆæ°—è±¡åºãªã©ï¼‰</button>
      <div class="sep"></div>
      <button data-act="open-saved">ä¿å­˜SVGã‚’é–‹ãï¼ˆæœ¬ã‚¢ãƒ—ãƒªï¼‰</button>
    </div>

    <!-- æ›¸ãå‡ºã—ï¼ˆçµ±åˆï¼‰ -->
    <button id="exportBtn">æ›¸ãå‡ºã— â–¾</button>
    <div id="exportMenu" class="menu">
      <button data-act="export-stl">STLã‚’æ›¸ãå‡ºã—</button>
      <div class="sep"></div>
      <button data-act="save-svg">SVGã‚’ä¿å­˜</button>
    </div>

    <button id="panelToggle">ãƒ‘ãƒãƒ«</button>
  </header>

  <div id="viewer">
    <canvas id="c"></canvas>
    <div id="overlay">ãƒ‰ãƒ©ãƒƒã‚°ã§å›è»¢ / å³ãƒ‰ãƒ©ãƒƒã‚°ã§å¹³è¡Œç§»å‹• / ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ  / ç·šã‚’ãƒ‰ãƒ©ãƒƒã‚°ã§é«˜ã•å¤‰æ›´ï¼ˆShift=ã‚†ã£ãã‚Š / Alt=å¤§ããï¼‰</div>
    <div id="dragHud"></div>
  </div>

  <aside id="sidebar">
    <div class="section">
      <h2><span class="emo">âš™ï¸</span> å…¨ä½“è¨­å®š</h2>
      <div class="row"><label>èƒŒæ™¯è‰²</label><input id="bgColor" type="color" value="#dff0ff"></div>
      <div class="row"><label>åŸºæº–ï¼ˆè»¸ï¼†ã‚­ãƒ¥ãƒ¼ãƒ–ï¼‰</label><input id="basisVisible" type="checkbox" checked></div>
      <div class="row"><label>ã‚°ãƒªãƒƒãƒ‰ï¼ˆXY/ZXï¼‰</label><input id="gridVisible" type="checkbox" checked></div>
      <div class="row"><label>é«˜ã•å€ç‡ï¼ˆZï¼‰</label><input id="heightScale" type="range" min="0.1" max="20" step="0.1" value="5"></div>
      <div class="row"><label>ãƒ‰ãƒ©ãƒƒã‚°æ„Ÿåº¦</label><input id="dragSensitivity" type="range" min="0.05" max="2.0" step="0.05" value="0.3"></div>
      <div class="row"><label>ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°å¯†åº¦ï¼ˆèª­ã¿è¾¼ã¿ï¼‰</label><input id="sample" type="range" min="32" max="1000" step="1" value="240"></div>
    </div>

    <div class="section">
      <h2><span class="emo">ğŸ—ºï¸</span> å¤©æ°—å›³ç”»åƒï¼ˆä¸‹æ•·ãï¼‰</h2>
      <div class="row"><label>è¡¨ç¤ºã™ã‚‹</label><input id="imgVisible" type="checkbox" checked></div>
      <div class="row"><label>ä¸é€æ˜åº¦</label><input id="imgOpacity" type="range" min="0" max="1" step="0.01" value="0.9"></div>
      <div class="row"><label>é«˜ã•ï¼ˆZã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰</label><input id="imgHeight" type="range" min="-200" max="200" step="0.1" value="-0.1"></div>
    </div>

    <div class="section">
      <h2><span class="emo">ğŸ¤–</span> è‡ªå‹•é«˜ã•ï¼ˆãƒ©ãƒ™ãƒ«é †ï¼‰</h2>
      <div class="row"><label>è‡ªå‹•é«˜ã•ã‚’ä½¿ã†</label><input id="autoMode" type="checkbox"></div>
      <div class="row"><label>é–“éš”å€ç‡</label><input id="gapFactor" type="range" min="0.2" max="3" step="0.05" value="1"></div>
      <div class="row"><label>å¹³å¦ â†â†’ åˆæœŸé–“éš”</label><input id="autoBlend" type="range" min="0" max="1" step="0.01" value="1"></div>
      <div class="row"><span class="muted" id="labelInfo">ãƒ©ãƒ™ãƒ«æœªè§£æ</span><span></span></div>
    </div>

    <div class="section">
      <h2><span class="emo">ğŸ§µ</span> ç­‰åœ§ç·šãƒªã‚¹ãƒˆ</h2>
      <div id="list"></div>
    </div>
  </aside>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
import { STLExporter } from 'three/addons/exporters/STLExporter.js';
import * as pako from 'https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.esm.mjs';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

const PICK_TUBE_SCALE = 2.8;
/* å­¦æ ¡ç‰ˆ: ãƒ‘ã‚¤ãƒ—åŠå¾„ã‚’ã‚ã‹ã‚Šã‚„ã™ãå›ºå®šï¼ˆå¤ªã‚ï¼‰ */
const PIPE_RADIUS = 3.2;

/* ==== DOM refs ==== */
const ui = {
  app: document.getElementById('app'),
  canvas: document.getElementById('c'),
  dragHud: document.getElementById('dragHud'),
  projection: document.getElementById('projection'),
  viewSelect: document.getElementById('viewSelect'),
  openBtn: document.getElementById('openBtn'),
  exportBtn: document.getElementById('exportBtn'),
  openMenu: document.getElementById('openMenu'),
  exportMenu: document.getElementById('exportMenu'),
  fileRaw: document.getElementById('fileRaw'),
  fileSaved: document.getElementById('fileSaved'),
  panelToggle: document.getElementById('panelToggle'),
  bgColor: document.getElementById('bgColor'),
  basisVisible: document.getElementById('basisVisible'),
  gridVisible: document.getElementById('gridVisible'),
  heightScale: document.getElementById('heightScale'),
  dragSensitivity: document.getElementById('dragSensitivity'),
  sample: document.getElementById('sample'),
  imgVisible: document.getElementById('imgVisible'),
  imgOpacity: document.getElementById('imgOpacity'),
  imgHeight: document.getElementById('imgHeight'),
  autoMode: document.getElementById('autoMode'),
  gapFactor: document.getElementById('gapFactor'),
  autoBlend: document.getElementById('autoBlend'),
  labelInfo: document.getElementById('labelInfo'),
  list: document.getElementById('list'),
};

/* ==== renderer / scene ==== */
const renderer = new THREE.WebGLRenderer({canvas: ui.canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;

const scene = new THREE.Scene();
/* èƒŒæ™¯è‰²ã¯UIã®è‰²ã«ãƒªãƒ³ã‚¯ */
scene.background = new THREE.Color(ui.bgColor.value);

/* ==== cameras & controls ==== */
let controls, camera;
const perspCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 50000);
perspCamera.up.set(0,0,1);
perspCamera.position.set(450,300,200);

const orthoCamera = new THREE.OrthographicCamera(-500,500,500,-500,-50000,50000);
orthoCamera.up.set(0,0,1);
orthoCamera.position.copy(perspCamera.position);

function makeControls(cam){
  if(controls) controls.dispose();
  controls = new OrbitControls(cam, renderer.domElement);
  controls.enableDamping = true;
  controls.screenSpacePanning = false;
}
function setOrthoFrustum(){
  const v=document.getElementById('viewer'); const aspect=v.clientWidth/v.clientHeight;
  const box=new THREE.Box3().setFromObject(chartGroup);
  const s=new THREE.Vector3(); box.getSize(s);
  const maxDim=Math.max(s.x,s.y,s.z,100);
  const halfH=maxDim*0.7, halfW=halfH*aspect;
  orthoCamera.left=-halfW; orthoCamera.right=halfW; orthoCamera.top=halfH; orthoCamera.bottom=-halfH;
  orthoCamera.near=-maxDim*10; orthoCamera.far=maxDim*10; orthoCamera.updateProjectionMatrix();
}
function usePerspective(){ perspCamera.position.copy(camera.position); camera=perspCamera; makeControls(camera); controls.target.copy(_target); controls.update(); }
function useOrthographic(){ orthoCamera.position.copy(camera.position); setOrthoFrustum(); camera=orthoCamera; makeControls(camera); controls.target.copy(_target); controls.update(); }
let _target = new THREE.Vector3();
camera = perspCamera; makeControls(camera);

/* ==== lights / grid / basis ==== */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dl=new THREE.DirectionalLight(0xffffff,0.95); dl.position.set(400,300,500); scene.add(dl);
const gridXY=new THREE.GridHelper(1000,100,0xffffff,0xffffff); gridXY.rotation.x=Math.PI/2; gridXY.material.opacity=.6; gridXY.material.transparent=true; scene.add(gridXY);
const gridZX=new THREE.GridHelper(1000,100,0xffffff,0xffffff); gridZX.material.opacity=.35; gridZX.material.transparent=true; scene.add(gridZX);

const basis=new THREE.Group();
basis.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0),new THREE.Vector3(),300,0xff5f5f,50,20));
basis.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0),new THREE.Vector3(),300,0x14b8a6,50,20));
basis.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1),new THREE.Vector3(),300,0x60a5fa,50,20));
const fontLoader=new FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json',(font)=>{
  const mk=(ch,col,pos)=>{
    const g=new TextGeometry(ch,{font,size:42,height:5});
    g.computeBoundingBox();
    const m=new THREE.MeshBasicMaterial({color:col});
    const mesh=new THREE.Mesh(g,m);
    const w=g.boundingBox.max.x-g.boundingBox.min.x;
    mesh.position.set(pos.x-w/2,pos.y,pos.z);
    basis.add(mesh);
  };
  mk('X',0xff5f5f,{x:320,y:-20,z:0}); mk('Y',0x14b8a6,{x:0,y:320,z:0}); mk('Z',0x60a5fa,{x:0,y:-20,z:320});
});
const cube=new THREE.Mesh(new THREE.BoxGeometry(60,60,60),[
  new THREE.MeshStandardMaterial({color:0xff5f5f,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0xff5f5f,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x14b8a6,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x14b8a6,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x60a5fa,roughness:.35,metalness:.1}),
  new THREE.MeshStandardMaterial({color:0x60a5fa,roughness:.35,metalness:.1}),
]); cube.position.set(0,0,30); basis.add(cube); scene.add(basis);

/* ==== containers ==== */
const chartGroup=new THREE.Group(); scene.add(chartGroup);
const rootLines=new THREE.Group(); chartGroup.add(rootLines);
/* item: pipeMesh, pickPipeMesh, pathPoints, path2D, height, ui, userColor(null=auto), kind */
let items=[];
let weatherPlane=null, lastSvgDims=null, lastRawSvgText="";
let linesOffset = new THREE.Vector3(0,0,0);

/* ==== render loop / resize ==== */
function resize(){
  const v=document.getElementById('viewer');
  renderer.setSize(v.clientWidth,v.clientHeight,false);
  if(camera.isPerspectiveCamera){ camera.aspect=v.clientWidth/v.clientHeight; camera.updateProjectionMatrix(); }
  else setOrthoFrustum();
}
addEventListener('resize',resize); resize();
(function anim(){ requestAnimationFrame(anim); controls.update(); renderer.render(scene,camera); })();

/* ==== views ==== */
function fitView(target=chartGroup){
  const b=new THREE.Box3().setFromObject(target); const sz=new THREE.Vector3(), cen=new THREE.Vector3();
  b.getSize(sz); b.getCenter(cen); if(!(isFinite(sz.x)&&isFinite(sz.y))) return;
  _target.copy(cen);
  if(camera.isPerspectiveCamera){
    const maxDim=Math.max(sz.x,sz.y,sz.z);
    const dist=maxDim*1.2/Math.tan(THREE.MathUtils.degToRad(perspCamera.fov*0.5));
    const dir=new THREE.Vector3(.75,.55,.35).normalize();
    camera.position.copy(cen.clone().add(dir.multiplyScalar(dist)));
    camera.near=Math.max(.1,dist/1000); camera.far=dist*1000; camera.updateProjectionMatrix();
  }else{
    setOrthoFrustum();
    camera.position.copy(new THREE.Vector3(.75,.55,.35).normalize().multiplyScalar(Math.max(sz.x,sz.y,sz.z)*2).add(cen));
  }
  controls.target.copy(cen); controls.update();
}
function viewTop(){ const b=new THREE.Box3().setFromObject(chartGroup),c=new THREE.Vector3(),s=new THREE.Vector3(); b.getCenter(c); b.getSize(s); const dist=Math.max(s.x,s.y,s.z)*2+1; camera.position.set(c.x,c.y,c.z+dist); _target.copy(c); controls.target.copy(c); controls.update(); if(!camera.isPerspectiveCamera) setOrthoFrustum(); }
function viewFront(){ const b=new THREE.Box3().setFromObject(chartGroup),c=new THREE.Vector3(),s=new THREE.Vector3(); b.getCenter(c); b.getSize(s); const dist=Math.max(s.x,s.y,s.z)*2+1; camera.position.set(c.x,c.y-dist,c.z); _target.copy(c); controls.target.copy(c); controls.update(); if(!camera.isPerspectiveCamera) setOrthoFrustum(); }
function viewSide(){ const b=new THREE.Box3().setFromObject(chartGroup),c=new THREE.Vector3(),s=new THREE.Vector3(); b.getCenter(c); b.getSize(s); const dist=Math.max(s.x,s.y,s.z)*2+1; camera.position.set(c.x+dist,c.y,c.z); _target.copy(c); controls.target.copy(c); controls.update(); if(!camera.isPerspectiveCamera) setOrthoFrustum(); }

/* ==== helpers ==== */
function colorFromHeight(h,maxH){ if(maxH<=0 || h<=0) return new THREE.Color(0xff0000); const t=Math.min(Math.max(h/maxH,0),1); const c=new THREE.Color(); c.setHSL((2/3)*t,1,0.55); return c; }
function currentMaxHeightStrict(){ if(!items.length) return 0; let m=0; for(const it of items) if(it.height>m) m=it.height; return m; }

/* ==== geometry ==== */
function buildTubeGeometry(points, radius){
  const curve=new THREE.CatmullRomCurve3(points,false,'centripetal',0.5);
  const seg=Math.max(16, Math.min(2048, Math.floor(points.length*1.5)));
  return new THREE.TubeGeometry(curve, seg, radius, 12, false);
}

/* ==== èƒŒæ™¯SVG ==== */
function readSvgDims(svgEl){
  const vb=svgEl.getAttribute("viewBox");
  if(vb){ const a=vb.trim().split(/\s+|,/).map(Number); if(a.length===4&&a.every(n=>isFinite(n))) return {minX:a[0],minY:a[1],w:a[2],h:a[3]}; }
  const w=parseFloat((svgEl.getAttribute("width")||"").replace(/[^\d.]+/g,""));
  const h=parseFloat((svgEl.getAttribute("height")||"").replace(/[^\d.]+/g,""));
  if(isFinite(w)&&isFinite(h)&&w>0&&h>0) return {minX:0,minY:0,w,h};
  return {minX:0,minY:0,w:1000,h:1000};
}
function normalizeSvgRoot(svgEl){
  const {minX,minY,w,h}=readSvgDims(svgEl);
  svgEl.setAttribute("width", String(w));
  svgEl.setAttribute("height", String(h));
  if(minX!==0 || minY!==0){
    const g = svgEl.ownerDocument.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("transform",`translate(${-minX},${-minY})`);
    while(svgEl.firstChild) g.appendChild(svgEl.firstChild);
    svgEl.appendChild(g);
  }
  svgEl.setAttribute("viewBox",`0 0 ${w} ${h}`);
  return {w,h};
}
async function buildOrUpdateWeatherPlane(rawSvgText){
  if(!lastSvgDims) return; const {w,h}=lastSvgDims;
  const tex=await new THREE.TextureLoader().loadAsync('data:image/svg+xml;charset=utf-8,'+encodeURIComponent(rawSvgText));
  tex.colorSpace=THREE.SRGBColorSpace;
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  tex.generateMipmaps = true;
  tex.minFilter = THREE.LinearMipmapLinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.flipY=false;
  const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:parseFloat(ui.imgOpacity.value), side:THREE.DoubleSide});
  const geom=new THREE.PlaneGeometry(w,h);
  if(!weatherPlane){ weatherPlane=new THREE.Mesh(geom,mat); weatherPlane.renderOrder=-1; chartGroup.add(weatherPlane); }
  else{
    weatherPlane.geometry.dispose();
    weatherPlane.material.map?.dispose();
    weatherPlane.material.dispose();
    weatherPlane.geometry=geom; weatherPlane.material=mat;
  }
  weatherPlane.position.set(0,0,0);
  weatherPlane.scale.set(1,-1,1);
  applyImageUI();
}
function applyImageUI(){
  if(!weatherPlane) return;
  weatherPlane.visible=ui.imgVisible.checked;
  weatherPlane.material.opacity=parseFloat(ui.imgOpacity.value);
  const s=parseFloat(ui.heightScale.value);
  weatherPlane.position.z=parseFloat(ui.imgHeight.value)*s;
}
['imgVisible','imgOpacity','imgHeight','heightScale'].forEach(id=>ui[id].addEventListener('input',applyImageUI));

/* ==== SVG â†’ items ==== */
function centroidXY(pts){ let sx=0,sy=0; for(const p of pts){sx+=p.x;sy+=p.y;} const n=pts.length||1; return {x:sx/n,y:sy/n}; }
function polygonArea(pts){ let a=0; for(let i=0;i<pts.length;i++){ const p=pts[i], q=pts[(i+1)%pts.length]; a += p.x*q.y - q.x*p.y; } return Math.abs(a)/2; }

async function loadSVGFromString(svgText){
  rootLines.clear(); items=[]; ui.list.innerHTML='';
  const loader=new SVGLoader(); let data;
  try{ data=loader.parse(svgText); }catch(e){ console.error('SVG parse å¤±æ•—',e); return; }

  const linesGroup=new THREE.Group();
  const sampleN=parseInt(ui.sample.value,10);

  for(const p of data.paths){
    const style=p.userData?.style||{}; const stroke=(style.stroke && style.stroke!=='none')?style.stroke:"#9aa4b2";
    for(const sub of p.subPaths){
      const pts2=sub.getPoints(Math.max(2,sampleN)); if(pts2.length<2) continue;
      const pts3=pts2.map(pt=>new THREE.Vector3(+pt.x, -pt.y, 0));

      const pipeGeom = buildTubeGeometry(pts3, PIPE_RADIUS);
      const pipeMat  = new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.6, metalness:.06, side:THREE.DoubleSide});
      const pipeMesh = new THREE.Mesh(pipeGeom, pipeMat);
      const pickPipeGeom = buildTubeGeometry(pts3, PIPE_RADIUS * PICK_TUBE_SCALE);
      const pickPipeMat  = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false});
      const pickPipeMesh = new THREE.Mesh(pickPipeGeom, pickPipeMat); pickPipeMesh.renderOrder = -1000;

      const cen=centroidXY(pts2), area=polygonArea(pts2);
      items.push({
        pipeMesh, pickPipeMesh,
        activePick: pickPipeMesh,
        pathPoints:pts3, path2D: pts2.map(pt=>({x:+pt.x,y:+pt.y})),
        height:0, ui:{}, centroid:cen, pressure:undefined, area, autoTarget:0,
        userColor:null, kind:'svg'
      });
      linesGroup.add(pipeMesh, pickPipeMesh);
    }
  }

  const box=new THREE.Box3().setFromObject(linesGroup); const cen3=new THREE.Vector3(), sz=new THREE.Vector3();
  box.getCenter(cen3); box.getSize(sz);
  linesGroup.position.set(-cen3.x, -cen3.y, 0);
  rootLines.add(linesGroup);
  linesOffset.copy(linesGroup.position);

  const scale=600/Math.max(sz.x,sz.y); chartGroup.scale.setScalar(isFinite(scale)&&scale>0?scale:1);

  await assignPressuresFromLabelsOrAreas();
  if (ui.autoMode.checked) applyAutoHeights();
  buildList(true);
  updateHeightsAndColors();
  fitView(chartGroup);
}

/* ==== ãƒ©ãƒ™ãƒ«æ¨å®š ==== */
function parseTranslate(tf){ 
  let tx=0,ty=0; if(!tf) return {tx,ty};
  const m=tf.match(/matrix\(([^)]+)\)/);
  if(m){const a=m[1].split(/[ ,]+/).map(Number); if(a.length===6&&a.every(n=>isFinite(n))){tx+=a[4];ty+=a[5];}}
  const t=tf.match(/translate\(([^)]+)\)/);
  if(t){const a=t[1].split(/[ ,]+\s*/).map(Number); if(a.length>=1) tx+=a[0]||0; if(a.length>=2) ty+=a[1]||0;}
  return {tx,ty};
}
function estimateXY(el){ let x=parseFloat(el.getAttribute("x")||"0"), y=parseFloat(el.getAttribute("y")||"0"), cur=el; while(cur&&cur.nodeType===1){ const tf=cur.getAttribute&&cur.getAttribute("transform"); const {tx,ty}=parseTranslate(tf||""); x+=tx; y+=ty; cur=cur.parentNode; } return {x,y}; }
function readPressureLabels(svgText){
  const doc=new DOMParser().parseFromString(svgText,"image/svg+xml"); const svg=doc.querySelector("svg"); if(!svg) return [];
  const labels=[]; for(const t of doc.querySelectorAll("text")){
    const raw=(t.textContent||"").trim(); const m=raw.match(/(-?\d{3,4})/); if(!m) continue;
    const val=parseInt(m[1],10); if(!isFinite(val)||val<800||val>1100) continue;
    const {x,y}=estimateXY(t); labels.push({x,y,value:val});
  } return labels;
}
async function assignPressuresFromLabelsOrAreas(){
  const labs=readPressureLabels(lastRawSvgText);
  if(labs.length){
    ui.labelInfo.textContent=`æ¤œå‡ºãƒ©ãƒ™ãƒ«: ${labs.length} å€‹`;
    for(const it of items){
      const {x,y}=it.centroid; let best=null,bd=Infinity;
      for(const lb of labs){ const d=(lb.x-x)**2+(lb.y-y)**2; if(d<bd){bd=d; best=lb;} }
      it.pressure=best?.value;
    }
  }else{
    ui.labelInfo.textContent='ãƒ©ãƒ™ãƒ«ãªã—ï¼šé¢ç©ãƒ™ãƒ¼ã‚¹ã§è‡ªå‹•é…ç½®';
    const arr=items.slice().sort((a,b)=>a.area-b.area);
    arr.forEach((it,idx)=>{ it.pressure=idx; });
  }
}

/* ==== auto / update ==== */
function applyAutoHeights(){
  const gf=parseFloat(ui.gapFactor.value);
  const blend=parseFloat(ui.autoBlend.value);
  const maxH=100*gf;
  const withP=items.filter(it=>isFinite(it.pressure)).sort((a,b)=>a.pressure-b.pressure);
  const n=withP.length;
  if(!n){ items.forEach(it=>it.height=0); updateHeightsAndColors(); return; }
  withP.forEach((it,idx)=>{ const t=(n===1)?0:(idx/(n-1)); it.autoTarget=t*maxH; });
  for(const it of items){ it.height=(it.autoTarget||0)*blend; }
  updateHeightsAndColors();
}
function updateHeightsAndColors(){
  const s=parseFloat(ui.heightScale.value);
  const maxH=currentMaxHeightStrict();
  for(const it of items){
    const z = it.height * s;
    it.pipeMesh.position.z = z;
    it.pickPipeMesh.position.z = z;

    const col = it.userColor ? new THREE.Color(it.userColor) : colorFromHeight(it.height, maxH);
    it.pipeMesh.material.color.copy(col);
    if(it.ui?.color) it.ui.color.value = `#${col.getHexString()}`;
  }
}

/* ==== ãƒ‘ãƒãƒ« ==== */
function focusPanelCardForItem(it){
  const el = it?.ui?.card;
  if(!el) return;
  el.classList.add('focus-ring');
  el.setAttribute('tabindex','-1');
  el.focus({preventScroll:true});
  el.scrollIntoView({block:'nearest', behavior:'smooth'});
  setTimeout(()=>el.classList.remove('focus-ring'), 900);
}
function buildList(orderByPressure=false){
  ui.list.innerHTML='';
  let arr=items.slice();
  if(orderByPressure){
    arr.sort((a,b)=>{
      const ap=isFinite(a.pressure)?a.pressure:Infinity;
      const bp=isFinite(b.pressure)?b.pressure:Infinity;
      return ap-bp;
    });
  }
  let i=0;
  for(const it of arr){
    const card=document.createElement('div'); card.className='card';
    const t=document.createElement('div'); t.className='t';
    const c=document.createElement('span'); c.className='chip'; c.textContent=`ç·š ${(++i).toString().padStart(2,'0')}`;
    const vis=document.createElement('input'); vis.type='checkbox'; vis.checked=true; vis.title='è¡¨ç¤º/éè¡¨ç¤º';
    vis.onchange=()=>{ it.pipeMesh.visible = vis.checked; it.pickPipeMesh.visible = vis.checked; };
    const color=document.createElement('input'); color.type='color'; color.disabled = (it.kind==='svg'); // SVGã¯è‡ªå‹•è‰²
    const tag=document.createElement('span'); tag.className='small muted'; tag.textContent=(it.kind==='svg')?(isFinite(it.pressure)?`ãƒ©ãƒ™ãƒ«P=${it.pressure}`:`P=?`):'';
    t.append(c, vis, color, tag); card.appendChild(t);

    const row1=document.createElement('div'); row1.className='row';
    const lab=document.createElement('label'); lab.textContent='é«˜ã•ï¼ˆZï¼‰';
    const slider=document.createElement('input'); slider.type='range'; slider.min=-2000; slider.max=2000; slider.step=0.1; slider.value=it.height;
    slider.oninput=()=>{ it.height=parseFloat(slider.value); if(it.ui?.num) it.ui.num.value=it.height.toFixed(2); updateHeightsAndColors(); };
    row1.append(lab,slider); card.appendChild(row1);

    const row2=document.createElement('div'); row2.className='row';
    const hint=document.createElement('span'); hint.className='small'; hint.textContent='æ•°å­—ã§ã‚‚èª¿æ•´ã§ãã‚‹ã‚ˆ';
    const num=document.createElement('input'); num.type='number'; num.className='small'; num.step=0.1; num.style.width='110px'; num.value=it.height.toFixed(2);
    num.onchange=()=>{ const v=parseFloat(num.value)||0; it.height=v; slider.value=v; updateHeightsAndColors(); };
    row2.append(hint,num); card.appendChild(row2);

    const initCol = it.userColor ? it.userColor : `#${it.pipeMesh.material.color.getHexString()}`;
    color.value = initCol;
    color.oninput = ()=>{ const v=color.value; it.userColor=v; it.pipeMesh.material.color.set(v); };

    it.ui={slider,num,color,vis,card};
    ui.list.appendChild(card);
  }
}

/* ==== ãƒ”ãƒƒã‚¯ & ãƒ‰ãƒ©ãƒƒã‚° ==== */
const raycaster=new THREE.Raycaster(); const pointer=new THREE.Vector2();
let draggingItem=null; let lastClientY=0;
function pickFromClientXY(clientX, clientY){
  const rect=ui.canvas.getBoundingClientRect();
  pointer.set((clientX-rect.left)/rect.width*2-1, -(clientY-rect.top)/rect.height*2+1);
  raycaster.setFromCamera(pointer,camera);
  const targets = items.map(i=>i.pickPipeMesh).filter(m=>m && m.visible);
  const hits = raycaster.intersectObjects(targets, false);
  if(!hits[0]) return null;
  const obj = hits[0].object;
  return items.find(it => it.pickPipeMesh===obj);
}
function updateHudByClientXY(clientX, clientY, h){
  const rect=ui.canvas.getBoundingClientRect();
  ui.dragHud.style.left = (clientX-rect.left)+'px';
  ui.dragHud.style.top  = (clientY-rect.top)+'px';
  const maxH=currentMaxHeightStrict();
  const col=colorFromHeight(h,maxH);
  const r=Math.round(col.r*255), g=Math.round(col.g*255), b=Math.round(col.b*255);
  ui.dragHud.style.background=`rgba(${r},${g},${b},.9)`;
  ui.dragHud.textContent=`é«˜ã• Z = ${h.toFixed(2)}`;
}
ui.canvas.addEventListener('pointerdown',(e)=>{
  if(e.button!==0) return;
  const hit = pickFromClientXY(e.clientX, e.clientY);
  if(hit){
    draggingItem = hit;
    lastClientY = e.clientY;
    controls.enabled = false;
    ui.canvas.classList.add('grabbing');
    ui.dragHud.style.display='block';
    focusPanelCardForItem(draggingItem);
    updateHudByClientXY(e.clientX, e.clientY, draggingItem.height);
    ui.canvas.setPointerCapture(e.pointerId);
    e.preventDefault();
  }
});
ui.canvas.addEventListener('pointermove',(e)=>{
  if(draggingItem){
    const dy = e.clientY - lastClientY; lastClientY = e.clientY;
    let sens=parseFloat(ui.dragSensitivity.value);
    if(e.shiftKey) sens*=.2; if(e.altKey) sens*=3.0;
    draggingItem.height += -dy * sens;
    if(draggingItem.ui?.slider) draggingItem.ui.slider.value=draggingItem.height;
    if(draggingItem.ui?.num)    draggingItem.ui.num.value=draggingItem.height.toFixed(2);
    updateHeightsAndColors();
    updateHudByClientXY(e.clientX, e.clientY, draggingItem.height);
    e.preventDefault();
    return;
  }
  const over = pickFromClientXY(e.clientX, e.clientY);
  ui.canvas.classList.toggle('hovering', !!over);
});
function endDrag(e){
  if(draggingItem){
    updateHeightsAndColors();
    draggingItem=null;
    controls.enabled=true;
    ui.canvas.classList.remove('grabbing');
    ui.dragHud.style.display='none';
    if(e) ui.canvas.releasePointerCapture(e.pointerId);
  }
}
ui.canvas.addEventListener('pointerup', endDrag);
ui.canvas.addEventListener('pointercancel', endDrag);
ui.canvas.addEventListener('pointerleave', endDrag);

/* ==== I/O ==== */
function tryDecodeUtf8(u8){ try{ const txt=new TextDecoder("utf-8",{fatal:false}).decode(u8); if(txt.includes("<svg")||txt.includes("<?xml")) return txt; }catch{} return null; }
async function readSvgOrSvgz(file){
  const buf=await file.arrayBuffer(); const u8=new Uint8Array(buf);
  const plain=tryDecodeUtf8(u8); if(plain) return plain;
  const isGzip=u8.length>=2 && u8[0]===0x1f && u8[1]===0x8b;
  if(isGzip || (file.name||"").toLowerCase().endsWith(".svgz")){
    try{ const t=new TextDecoder("utf-8").decode(pako.ungzip(u8)); if(t.includes("<svg")) return t; }catch(e1){
      try{ const t=new TextDecoder("utf-8").decode(pako.inflate(u8)); if(t.includes("<svg")) return t; }catch(e2){
        try{ const t=new TextDecoder("utf-8").decode(pako.inflateRaw(u8)); if(t.includes("<svg")) return t; }catch(e3){}
      }
    }
  }
  const fb=new TextDecoder("utf-8",{fatal:false}).decode(u8);
  if(fb && fb.includes("<svg")) return fb;
  throw new Error("SVGZã®è§£å‡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
}
function extractIsobarsOnly(svgText){
  const doc=new DOMParser().parseFromString(svgText,"image/svg+xml");
  const svg=doc.querySelector("svg"); if(!svg) return svgText; 
  const {w,h}=normalizeSvgRoot(svg);
  lastSvgDims={w,h};
  const contours=svg.querySelectorAll('g#weatherChart g.contour');
  const outDoc=document.implementation.createDocument("http://www.w3.org/2000/svg","svg",null);
  const outSvg=outDoc.documentElement; outSvg.setAttribute("xmlns","http://www.w3.org/2000/svg");
  outSvg.setAttribute("viewBox",`0 0 ${w} ${h}`); outSvg.setAttribute("width",String(w)); outSvg.setAttribute("height",String(h));
  const DEFAULT_STROKE="#9aa4b2";
  contours.forEach(cont=>{
    cont.querySelectorAll("path, polyline, circle, rect, ellipse").forEach(el=>{
      const dup=el.cloneNode(true);
      dup.setAttribute("fill","none");
      if(!dup.getAttribute("stroke")||dup.getAttribute("stroke")==="none") dup.setAttribute("stroke",DEFAULT_STROKE);
      if(!dup.getAttribute("stroke-width")) dup.setAttribute("stroke-width","1");
      outSvg.appendChild(dup);
    });
  });
  if(!outSvg.firstElementChild) return new XMLSerializer().serializeToString(svg);
  return new XMLSerializer().serializeToString(outSvg);
}

/* ==== ä¿å­˜ï¼ˆæ­£è¦åŒ–åº§æ¨™ï¼‰ ==== */
function pointsToAttr2D(points){ return points.map(p=>`${(+p.x).toFixed(3)},${(+p.y).toFixed(3)}`).join(' '); }
function pointsToAttr3D(points){ return points.map(p=>`${(+p.x).toFixed(3)} ${(+p.y).toFixed(3)} ${(+p.z).toFixed(3)}`).join(';'); }
function getCanonicalPts3(it){
  if(it.kind === 'svg') return it.pathPoints.map(p=>p.clone());
  return it.pathPoints.map(p=> new THREE.Vector3(p.x - linesOffset.x, p.y - linesOffset.y, p.z));
}
function canonical3Dto2D(pts3){ return pts3.map(v=>({x:v.x, y:-v.y})); }

function buildProjectSVG(){
  const doc = document.implementation.createDocument("http://www.w3.org/2000/svg","svg",null);
  const svg = doc.documentElement;
  svg.setAttribute("xmlns","http://www.w3.org/2000/svg");
  if(lastSvgDims){ svg.setAttribute("viewBox",`0 0 ${lastSvgDims.w} ${lastSvgDims.h}`); svg.setAttribute("width",String(lastSvgDims.w)); svg.setAttribute("height",String(lastSvgDims.h)); }
  svg.setAttribute("data-app","3disobarsplus");

  if(lastRawSvgText){
    const bgDoc = new DOMParser().parseFromString(lastRawSvgText,"image/svg+xml");
    const bgRoot = bgDoc.querySelector("svg");
    if(bgRoot){
      const g = doc.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("id","weatherEmbedded");
      for(const node of Array.from(bgRoot.childNodes)){
        g.appendChild(doc.importNode(node,true));
      }
      svg.appendChild(g);
    }
  }

  const iso = doc.createElementNS("http://www.w3.org/2000/svg","g");
  iso.setAttribute("id","isobars3d");
  iso.setAttribute("data-app","3disobarsplus");
  iso.setAttribute("data-version","5");
  for(const it of items){
    const ptsCanon3 = getCanonicalPts3(it);
    const pts2 = canonical3Dto2D(ptsCanon3);
    const poly = doc.createElementNS("http://www.w3.org/2000/svg","polyline");
    poly.setAttribute("fill","none");
    const col = it.userColor ? it.userColor : `#${it.pipeMesh.material.color.getHexString()}`;
    poly.setAttribute("stroke", col);
    poly.setAttribute("stroke-width","1");
    poly.setAttribute("points", pointsToAttr2D(pts2));
    poly.setAttribute("data-pts3", pointsToAttr3D(ptsCanon3));
    poly.setAttribute("data-height", String(+it.height.toFixed(3)));
    poly.setAttribute("data-visible", (it.ui?.vis?.checked ?? true) ? "1":"0");
    poly.setAttribute("data-kind", it.kind||'svg');
    poly.setAttribute("data-usercolor", it.userColor ? "1":"0");
    iso.appendChild(poly);
  }
  svg.appendChild(iso);

  const meta = doc.createElementNS("http://www.w3.org/2000/svg","metadata");
  meta.textContent = JSON.stringify({
    app:"3disobarsplus",
    savedAt: new Date().toISOString(),
    autoMode: ui.autoMode.checked,
    heightScale: parseFloat(ui.heightScale.value)
  });
  svg.appendChild(meta);

  return new XMLSerializer().serializeToString(svg);
}
function doSaveSVG(){
  const svgText = buildProjectSVG();
  const blob = new Blob([svgText], {type:"image/svg+xml"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = '3disobars_school.svg';
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href),1000);
}
function doExportSTL(){
  const exporter=new STLExporter();
  const group=new THREE.Group();
  for(const it of items){
    const visible = (it.ui?.vis?.checked ?? true);
    if(!visible) continue;
    group.add(it.pipeMesh.clone());
  }
  const stl=exporter.parse(group);
  const blob=new Blob([stl],{type:'model/stl'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='isobars_school.stl'; a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

/* ==== ä¿å­˜SVGã®å†èª­è¾¼ ==== */
function parsePts3Attr(str){
  const out=[]; if(!str) return out;
  str.split(';').forEach(tok=>{
    const [x,y,z]=tok.trim().split(/[ ,]+/).map(Number);
    if(isFinite(x)&&isFinite(y)&&isFinite(z)) out.push(new THREE.Vector3(x,y,z));
  });
  return out;
}
function parsePointsAttr2D(str){
  const out=[]; if(!str) return out;
  str.trim().split(/\s+/).forEach(tok=>{
    const [x,y]=tok.split(',').map(Number);
    if(isFinite(x)&&isFinite(y)) out.push({x,y});
  });
  return out;
}
async function loadProjectSVG(svgText){
  const doc = new DOMParser().parseFromString(svgText,"image/svg+xml");
  const svg = doc.querySelector("svg");
  if(!svg){ console.warn('SVGãƒ«ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }

  const {w,h}=normalizeSvgRoot(svg);
  lastSvgDims={w,h};

  const svgClone = svg.cloneNode(true);
  const iso = svgClone.querySelector('g#isobars3d[data-app="3disobarsplus"]');
  if(iso) iso.parentNode.removeChild(iso);
  const bgText = new XMLSerializer().serializeToString(svgClone);
  lastRawSvgText = bgText;
  await buildOrUpdateWeatherPlane(bgText);

  rootLines.clear(); items=[]; ui.list.innerHTML='';
  const isoGroup = svg.querySelector('g#isobars3d[data-app="3disobarsplus"]');
  if(!isoGroup){ console.warn('isobars3d ã‚°ãƒ«ãƒ¼ãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }

  const linesGroup=new THREE.Group();
  const polylines = Array.from(isoGroup.querySelectorAll('polyline'));
  for(const poly of polylines){
    const pts3 = parsePts3Attr(poly.getAttribute('data-pts3')||'');
    const pts2 = parsePointsAttr2D(poly.getAttribute('points')||'');
    const height = parseFloat(poly.getAttribute('data-height')||'0')||0;
    const stroke = poly.getAttribute('stroke') || '#9aa4b2';
    const visible = poly.getAttribute('data-visible')!=="0";
    const userColorFlag = poly.getAttribute('data-usercolor');

    const pathPoints = (pts3.length? pts3 : pts2.map(p=>new THREE.Vector3(p.x, -p.y, 0)));

    const pipeMesh = new THREE.Mesh(
      buildTubeGeometry(pathPoints, PIPE_RADIUS),
      new THREE.MeshStandardMaterial({color:new THREE.Color(stroke), roughness:.6, metalness:.06, side:THREE.DoubleSide})
    );
    const pickPipeMesh = new THREE.Mesh(
      buildTubeGeometry(pathPoints, PIPE_RADIUS*PICK_TUBE_SCALE),
      new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.001, depthWrite:false})
    ); pickPipeMesh.renderOrder=-1000;

    const userColor = (userColorFlag==='1') ? stroke : null;

    const it = {
      pipeMesh, pickPipeMesh,
      activePick: pickPipeMesh,
      pathPoints, path2D: pts2,
      height, ui:{}, centroid:{x:0,y:0}, pressure:undefined, area:0, autoTarget:0,
      userColor, kind:'svg'
    };
    items.push(it);
    linesGroup.add(pipeMesh, pickPipeMesh);
    it.ui.vis = {checked:visible};
    pipeMesh.visible = visible;
    pickPipeMesh.visible = visible;
  }

  const box=new THREE.Box3().setFromObject(linesGroup); const cen3=new THREE.Vector3(), sz=new THREE.Vector3();
  box.getCenter(cen3); box.getSize(sz);
  linesGroup.position.set(-cen3.x, -cen3.y, 0);
  rootLines.add(linesGroup);
  linesOffset.copy(linesGroup.position);

  const scale=600/Math.max(sz.x,sz.y); chartGroup.scale.setScalar(isFinite(scale)&&scale>0?scale:1);

  buildList(true);
  updateHeightsAndColors();
  fitView(chartGroup);
}

/* ==== ãƒ¡ãƒ‹ãƒ¥ãƒ¼ ==== */
function toggleMenu(menu, anchorBtn){
  const open = !menu.classList.contains('open');
  document.querySelectorAll('.menu.open').forEach(m=>m.classList.remove('open'));
  if(!open) return;
  const r = anchorBtn.getBoundingClientRect();
  menu.style.left = (r.left)+'px';
  menu.style.top  = (r.bottom+4)+'px';
  menu.classList.add('open');
}
function closeMenus(){ document.querySelectorAll('.menu.open').forEach(m=>m.classList.remove('open')); }
document.getElementById('openBtn').addEventListener('click', ()=> toggleMenu(ui.openMenu, ui.openBtn));
document.getElementById('exportBtn').addEventListener('click', ()=> toggleMenu(ui.exportMenu, ui.exportBtn));
addEventListener('click', (e)=>{
  if(!e.target.closest('.menu') && ![ui.openBtn, ui.exportBtn].includes(e.target)) closeMenus();
});
ui.openMenu.addEventListener('click', (e)=>{
  const act = e.target?.dataset?.act; if(!act) return;
  closeMenus();
  if(act==='open-raw') ui.fileRaw.click();
  if(act==='open-saved') ui.fileSaved.click();
});
ui.exportMenu.addEventListener('click', (e)=>{
  const act = e.target?.dataset?.act; if(!act) return;
  closeMenus();
  if(act==='export-stl') doExportSTL();
  if(act==='save-svg')  doSaveSVG();
});

/* ==== å…¥å‡ºåŠ›ã‚¤ãƒ™ãƒ³ãƒˆ ==== */
ui.fileRaw.addEventListener('change', async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  try{
    const raw=await readSvgOrSvgz(f);
    const doc=new DOMParser().parseFromString(raw,"image/svg+xml");
    const svg=doc.querySelector("svg");
    if(svg){
      const {w,h}=normalizeSvgRoot(svg);
      lastSvgDims={w,h};
      lastRawSvgText=new XMLSerializer().serializeToString(svg);
      await buildOrUpdateWeatherPlane(lastRawSvgText);
    }
    const only=extractIsobarsOnly(raw);
    await loadSVGFromString(only);
    fitView(chartGroup);
  }catch(err){ console.error('èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼',err); }
});
ui.fileSaved.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const text = await f.text();
  await loadProjectSVG(text);
});

/* ==== ãã®ä»–UI ==== */
ui.bgColor.addEventListener('input', e=>{ scene.background=new THREE.Color(e.target.value); });
ui.basisVisible.addEventListener('change', e=>{ basis.visible=e.target.checked; });
ui.gridVisible.addEventListener('change', e=>{ const v=e.target.checked; gridXY.visible=v; gridZX.visible=v; });
ui.heightScale.addEventListener('input', ()=>{ updateHeightsAndColors(); applyImageUI(); });
ui.viewSelect.addEventListener('change', e=>{ const v=e.target.value; if(v==='top') viewTop(); else if(v==='front') viewFront(); else if(v==='side') viewSide(); else fitView(chartGroup); });
ui.projection.addEventListener('change', e=>{ (e.target.value==='ortho')?useOrthographic():usePerspective(); fitView(chartGroup); });
ui.panelToggle.addEventListener('click', ()=>{ const open=ui.app.getAttribute('data-panel')!=='closed'; ui.app.setAttribute('data-panel', open?'closed':'open'); setTimeout(resize,0); });
ui.autoMode.addEventListener('change', ()=>{
  if(ui.autoMode.checked) applyAutoHeights();
  else { for(const it of items){ it.height=0; if(it.ui?.slider) it.ui.slider.value=0; if(it.ui?.num) it.ui.num.value='0.00'; } updateHeightsAndColors(); }
});
ui.gapFactor.addEventListener('input', ()=>{ if(ui.autoMode.checked) applyAutoHeights(); });
ui.autoBlend.addEventListener('input', ()=>{ if(ui.autoMode.checked) applyAutoHeights(); });

/* åˆæœŸå¯è¦– */
basis.visible=true; gridXY.visible=true; gridZX.visible=true;
</script>
</body>
</html>
